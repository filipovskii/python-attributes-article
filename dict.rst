__dict__
========

Атрибуты объекта можно условно разделить две группы: определённые python-ом (такие как **__class__**, **__bases__**) и определённые пользователем, о них я как раз собираюсь рассказать. 

`__dict__` согласно этой классификации, относится к "системным" (определённым python-ом) атрибутам. Его задача - хранить пользовательские атрибуты. Он представляет собой dictionary, в котором ключом является *имя_атрибута*, значением, соответственно, *значение_атрибута*. 
    
Чтобы найти атрибут объекта `o`, python обыскивает:

1. Сам объект (`o.__dict__` и его системные атрибуты).
2. Класс объекта (`o.__class__.__dict__`). Только `__dict__` класса, не системные атрибуты.
3. Классы, от которых унасаледован класс объекта (`o.__class__.__bases__.__dict__`).

Таким образом, с помощью `__dict__` атрибут может быть определён как для конкретного экземпляра, так и для класса (то есть для всех объектов, которые являются экземплярами данного класса).

.. code-block:: python

    class StuffHolder:
        stuff = "class stuff"

    a = StuffHolder()
    b = StuffHolder()
    a.stuff     # "class stuff"
    b.stuff     # "class stuff"
    
    b.b_stuff = "b stuff"
    b.b_stuff   # "b stuff"
    a.b_stuff   # AttributeError

В примере описан класс `StuffHolder` с одним атрибутом `stuff`, который, наследуют оба его экземпляра. Добавление объекту `b` атрибута `b_stuff`, никак не отражается на `a`.

Посмотрим на `__dict__` всех действующих лиц:

.. code-block:: python

    StuffHolder.__dict__    # {... 'stuff': 'class stuff' ...} 
    a.__dict__              # {}
    b.__dict__              # {'b_stuff': 'b stuff'}

    a.__class__             # <class '__main__.StuffHolder'>
    b.__class__             # <class '__main__.StuffHolder'>

(У класса StuffHolder в `__dict__` хранится объект класса dict_proxy с кучей разного барахла, на которое пока не нужно обращать внимание)

Ни у `a` ни у `b` в `__dict__` нет атрибута `stuff`, не найдя его там, механизм поиска ищет его в `__dict__` класса (`StuffHolder`), успешно находит и возвращает значение, присвоенное ему в классе. Ссылка на класс хранится в атрибуте **__class__** объекта.


Поиск атрибута происходит во время выполнения, так что даже после создания экземпляров, все изменения в `__dict__` класса отразятся в них:

.. code-block:: python

    a.new_stuff                 # AttributeError
    b.new_stuff                 # AttributeError

    StuffHolder.new_stuff = "new"
    StuffHolder.__dict__        # {... 'stuff': 'class stuff', 'new_stuff': 'new'...}
    a.new_stuff                 # "new"
    b.new_stuff                 # "new"

В случае присваивания значения атрибуту экземпляра, изменяется только `__dict__` экземпляра, то есть значение в `__dict__` класса остаётся неизменным (в случае, если значением атрибута класса не является Data Descriptor):

.. code-block:: python

    stuffholder.__dict__    # {... 'stuff': 'class stuff' ...}
    c = stuffholder()
    c.__dict__              # {}

    c.stuff = "more c stuff"
    c.__dict__              # {'stuff': 'more c stuff'}
    stuffholder.__dict__    # {... 'stuff': 'class stuff' ...}
    

Если имёна атрибутов в классе и экземпляре совпадают, интерпретатор при поиске значения выдаст значение экземпляра (в случае, если значением атрибута класса не является Data Descriptor):


.. code-block:: python

    StuffHolder.__dict__    # {... 'stuff': 'class stuff' ...}
    d = StuffHolder()
    d.stuff                 # "class stuff"

    d.stuff = "d stuff"
    d.stuff                 # "d  stuff"

По большому счёту это всё, что можно сказать про `__dict__`. Это хранилище атрибутов, определённых пользователем. Поиск в нём производится во время выполнения и при поиске учитывается `__dict__` класса объекта и базовых классов. Также важно знать, что есть несколько способов переопределить это поведение. Одним из них является великий и могучий Дескриптор!
